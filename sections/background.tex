%!TEX root=../ast2016.tex

\section{Background}
\label{sec:background}

\input{figures/nist-weather}

\inlineheading{Relational Database Schemas}
\Figure{fig:nistweather} shows SQL \sql{CREATE TABLE} statements for the ``\NistWeather'' schema, which is a part of the NIST SQL conformance test suite\footnote{\url{http://www.itl.nist.gov/div897/ctg/sql_form.htm}}. The schema defines two tables. The ``\sql{Stats}'' table (lines 10--19) is for storing rainfall and temperature statistics for a given month pertaining to a particular weather station, the details of which are stored in the ``\sql{Station}'' table (lines 1--9). The definition of each table involves a number of different columns, each with an associated data type, and a series of integrity constraints, highlighted in the figure in pink. 

The definition of integrity constraints protect the validity and consistency of data stored in the tables of the database. For instance, the \sql{MONTH} columns of the \sql{Stats} table has a ``\CHECK'' constraint defined on it (line 13) that ensures an integer \sql{MONTH} value can only be between 1 and 12. Further \CCs defined on both tables ensure that other column values are within certain valid ranges (lines 6, 8, 15 and 17). Relational databases allow columns to have missing or unknown values (denoted by the ``\NULL'' marker). To prevent inconsistency (for instance, with the \sql{MONTH} column) several columns have a ``\NOTNULL'' constraint defined on them, enforcing values to be present for those columns in all rows of the table concerned.
Furthermore, the \sql{Stats} table involves a ``foreign key'', as defined on line 11. Here, ``\sql{ID}'' column values in the \sql{Stats} table must match some value 
for the \sql{ID} column in a row of the \sql{Station} table. Finally, both tables have ``primary keys'' defined on them (lines 2 and 18). A primary key specifies a set of columns in the table that must have distinct sets of values for each row, and ensures the row is uniquely identifiable. 
%% This sentence could be cut if there is little space:
The primary key of the \sql{Stats} is multicolumn, involving the \sql{ID} and \sql{MONTH} columns.

\inlineheading{Testing Integrity Constraints}
Relational database schemas are an important artifact in a software application, defining the underlying model that is used to specify how an application will store and retrieve data. Integrity constraints are a key part of the definition of a relational database schema that defending the database from the insertion of spurious values. A poorly or incorrectly specified schema may leave an application open to a range of serious errors---for example, non-unique login IDs or negative values for prices or stock levels. For this reason, testing the database schema, and in particular its integrity constraints is an important activity that is recommended by industry practitioners \cite{DzoneDatabaseTesting}.

In our previous work, we have sought to define coverage criteria to test whether the integrity constraints of a database schema have been specified correctly \cite{McMinn2015}. These coverage criteria mandate the creation of test cases which take the form of a series of SQL \INSERT statements that involve rows of particular values to be submitted to the database. These values are intended to exercise the integrity constraints of the schema. Test cases contain especially selected values to check that either the integrity constraints are fulfilled or violated as expected. In the case that all integrity constraints of a table are fulfilled, the data in the \INSERT statement is admitted into the database. When a constraint is violated, the \INSERT statement is rejected by the DBMS with an error.

For example, the following \INSERT statement could be used to check that the integrity constraints of the ``\sql{Station}'' table admit certain values as expected. Given an empty table, the values embodied in the statement should be admitted into the table:

\vspace{-.25em}
\begin{center}
\scalebox{0.82}{
\begin{tabular}{l}
\sql{INSERT INTO Station(ID, CITY, STATE, LAT\_N, LONG\_W)} \\ 
\sql{VALUES(1, 'Austin', 'TX', 30, 98);}
\end{tabular}}
\end{center}
\vspace{-.25em}

Further \INSERT statements could then be used to test that the table {\it rejects} certain values as expected, for example using \NULL or out of range values for the \sql{LAT\_N} or \sql{LONG\_W} columns, violating the table's \NOTNULL and \CCs respectively, or attempting to use a value for \sql{ID} that has already been inserted into the table, violating the primary key of the table. 

Whereas traditional program testing involves assertions over values outputted from a program, database schema testing involves checking that \INSERT statements were accepted or rejected as expected. If the acceptance-rejection pattern for a series of \INSERT statements differs from that which was expected, a specification error may exist in the definition of the schema.

\inlineheading{Mutation Analysis of Relational Database Schemas}
Once a test suite has been created, its strength---that is, its potential fault-finding capability---can be evaluated using mutation analysis \cite{Jia2011}. Mutation analysis involves seeding small faults into the artifact under test to create {\it mutants} and then checking if the test suite behaves differently with the mutant compared with the original artifact. If a difference in behavior is found, the test suite is capable of distinguishing the faulty artifact from the original.

For instance, seeding a fault into the NistWeather schema could take the form of removing the \NOTNULL constraint on the \sql{MONTH} column of the \sql{Stats} table. In the faulty version, \NULL values would be admitted into a database table for the \sql{MONTH} column that would have previously have been rejected, due to violation of the integrity constraint. Therefore, an \INSERT statement in a test case with a \NULL value for \sql{MONTH} would be {\it accepted} for the mutant, that would be {\it rejected} for the original schema. A test suite with a test case involving such an \INSERT statement is therefore capable of detecting such a fault, and the mutant is said to be ``killed''. However, if the test suite did not involve any \INSERT statements with a \NULL value for \sql{MONTH}, the difference between the mutant and the original schema would not be exposed, and the mutant would still be alive. Such a test suite would have a lower {\it mutation score}, because it would kill fewer mutants, and would therefore be regarded as having a weaker fault detection capability. 

In our previous work \cite{Kapfhammer2013,Wright2013,Wright2014} we developed a series of mutation operators for the integrity constraints of relational database schemas. These include operators that add, remove and replace columns from constraints defined over one or more columns (e.g., \PK and \FKCs), add and remove \NNCs for columns, remove \CCs and alter the relational operators used within them (e.g., substituting ``\sql{>}'' for ``\sql{>=}''). 

One problem with mutation analysis in general, however, the large scope for faults and the numbers of mutants that may be needed to represent them. This can lead to very long running times, since every mutant needs to be evaluated against the test suite, reducing the practical applicability of the approach. This potential lack of scalability of mutation analysis for large software systems has prompted several researchers to develop techniques to reduce its execution costs, which were characterized into three groups by Offutt and Untch \cite{Offutt2001}: ``do fewer'', ``do smarter'' and ``do faster''. As its name suggests, the ``do fewer'' category involves evaluating a subset of the complete set of mutants according to some selection strategy, while the latter two categories involve techniques that approximate the result of standard mutation analysis, or otherwise reduce its execution cost.  

In this paper, we present a technique that accurately approximates the results of standard mutation analysis {\it and} reduces its execution costs, by virtual evaluation of mutants.

