%!TEX root=../ast2016.tex

\section{Background}
\label{sec:background}

\input{figures/nist-weather}

\inlineheading{Relational Database Schemas}
\Figure{fig:nistweather} shows SQL \sql{CREATE TABLE} statements for the ``\NistWeather'' schema from the NIST SQL conformance test suite\footnote{\url{http://www.itl.nist.gov/div897/ctg/sql_form.htm}}, designed for the storage of annual temperature and rainfall statistics. The schema involves two tables, one for rows of information about individual weather stations (``\sql{Station}'') and a table for rows of weather statistics collected from particular stations in a given month (``\sql{Stats}''). Each table defines a number of columns, each with an associated data type, and a series of integrity constraints, highlighted in the figure in pink. 

The role of an integrity constraint is to ensure that data in the database is sound, by defending it from the insertion of invalid values. For instance, the \sql{MONTH} columns of the \sql{Stats} table has a ``\CHECK'' constraint defined on it, which ensures that a \sql{MONTH} value can only be between 1 and 12. Further \CCs defined on both tables ensure that other column values are within certain valid ranges. In addition, several columns have a ``\NOTNULL'' constraint defined on them, which ensures that a value exists for that particular column in each of rows of the table. The \sql{Stats} table involves a ``foreign key''---the ``\sql{ID}'' column must be identical to an existing value for the corresponding \sql{ID} column in a row of the \sql{Station} table. Finally, both tables have ``primary keys'' defined on them. The \sql{Stats} table has a multicolumn primary key defined on the \sql{ID} and \sql{MONTH} columns, for instance. A primary key specifies a set of columns in the table that must have distinct sets of values for each row. This also ensures the row is uniquely identifiable for potential lookup up in future. 

\inlineheading{Testing Integrity Constraints}
Relational database schemas are an important artifact in a software application, as they define the underlying model in which application data will be stored, retrieved and manipulated. Integrity constraints are key in ensuring the consistency and validity of that data, and often provide the last line of defense against invalid data entries. A poorly or incorrectly specified schema may leave an application open to a range of serious errors---for example, non-unique login IDs or negative values for prices or stock levels. For this reason, testing the database schema, and in particular its integrity constraints is an important activity that is recommended by industry practitioners \cite{DzoneDatabaseTesting}.

In our previous work, we have sought to define coverage criteria for integrity constraint testing \cite{McMinn2015}. These coverage criteria mandate the creation of test cases that take the form of SQL \INSERT statements, involving data values to be added to tables of the database. The \INSERT statements are designed to exercise the integrity constraints of the schema, by satisfying them (and as such, allowing the data in the \INSERT statement to be admitted to the database), or violating them in some aspect (i.e., the data in the \INSERT statement is rejected).

For example, given an empty database, the following \INSERT statement could be used to the \NOTNULL and \CCs of the ``\sql{Station}'' table admit the correct values, by checking that the DBMS successfully admits the data into the database (i.e., the \INSERT statement is not rejected).

\vspace{-0.5em}
\begin{center}
\sql{\small INSERT INTO Station(ID, CITY, STATE, LAT\_N, LONG\_W) \\ VALUES(1, 'Austin', 'TX', 30, 98);}
\end{center}
\vspace{-0.5em}

Conversely, \INSERT statements may be composed to test that the schema correctly rejects invalid values for these constraints through the use of \NULL values or values that are out of range for each of the \CHECK constraints. The \PK may be tested by following the above statement with further \INSERT statements that involve unique and non-unique values for the \sql{ID} column.

\inlineheading{Mutation Analysis of Relational Database Schemas}
One way to evaluate the strength of a test suite (i.e., its potential fault-finding capability) is to use mutation analysis. Mutation analysis involves seeding small faults into the artifact under test to create {\it mutants} and then checking if the test suite behaves differently with the mutant compared with the original artifact. For example, the removal of a \NOTNULL constraint on a column would cause \NULL values to be accepted into a database table that would have previously have been rejected. An \INSERT statement in a test case with otherwise valid data other than the \NULL value would be accepted for the mutant, that would have been rejected for the original schema. The test suite has therefore detects such a fault and the mutant is said to be ``killed''.

Our previous work \cite{Kapfhammer2013,Wright2013,Wright2014} we developed a series of mutation operators for the integrity constraints of relational database schemas. These include operators that add, remove and exchange columns from constraints defined over one or more columns (i.e., \PKs, \FKs and \UCs), add and remove \NNCs to columns, remove \CCs and alter the relational operators used within them (e.g., substituting ``\sql{>}'' for ``\sql{>=}'').


