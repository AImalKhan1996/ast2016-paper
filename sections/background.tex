%!TEX root=../ast2016.tex

\section{Background}
\label{sec:background}

\input{figures/nist-weather}

\inlineheading{Relational Database Schemas} 
\Figure{fig:nistweather} shows the SQL for the ``\NistWeather'' schema, which is taken from the NIST SQL conformance test suite. It models the collection of annual temperature and rainfall statistics. The schema involves two tables, designed to contained rows of information about weather stations (``\sql{Station}'') and a table for rows of statistics collected from those particular stations in a given month (``\sql{Stats}''). Each table defines a number of columns, with associated data types along with a series of integrity constraints on those columns, highlighted in pink. The role of an integrity constraint is to preserve the validity of the data in the database, defending it from the insertion of certain ``illegal'' values. For example, the \sql{MONTH} columns of the \sql{Stats} table has a ``\CHECK'' constraint defined on it, to ensure that its value can only be between 1 and 12. Further \CCs ensure other column values are within valid limits. Several columns have a ``\NOTNULL'' constraint defined on them, ensuring that a value exists for that particular column in rows of the table. The \sql{Stats} table involves a ``foreign key''---the ``\sql{ID}'' column must be identical to an existing value for the corresponding \sql{ID} column in a row of the \sql{Station} table. Finally, both tables have ``primary keys'' defined on them---a constraint that specifies a set of columns in the table that must have distinct sets of values for each row, so that the row can be uniquely identified for potential lookup up in future. For example, the \sql{Stats} table has a multicolumn primary key defined on the \sql{ID} and \sql{MONTH} columns. 

\inlineheading{Testing Integrity Constraints}
Relational database schemas are a vital artefact in software applications. Integrity constraints in particular often provide the last line of defense against invalid data entries. A poorly or incorrectly specified schema may leave an application open to a range of serious errors---for example, non-unique login IDs or negative values for prices or stock levels. For this reason, testing the database schema is an important activity that is recommended by industry practitioners \cite{DzoneDatabaseTesting}. 

In our previous work, we have sought to define coverage criteria for integrity constraint testing \cite{McMinn2015}. These coverage criteria mandate the creation of test cases that take the form of SQL \INSERT statements, involving data values to be added to tables of the database. The \INSERT statements are designed to exercise the integrity constraints of the schema, by satisfying them (and as such, allowing the data in the \INSERT statement to be admitted to the database), or violating them in some aspect (i.e., the data in the \INSERT statement is rejected).

For example, given an empty database, the following \INSERT statement could be used to the \NOTNULL and \CCs of the ``\sql{Station}'' table admit the correct values, by checking that the DBMS successfully admits the data into the database (i.e., the \INSERT statement is not rejected).

\vspace{-0.5em}
\begin{center}
\sql{\small INSERT INTO Station(ID, CITY, STATE, LAT\_N, LONG\_W) \\ VALUES(1, 'Austin', 'TX', 30, 98);}
\end{center}
\vspace{-0.5em}

Conversely, \INSERT statements may be composed to test that the schema correctly rejects invalid values for these constraints through the use of \NULL values or values that are out of range for each of the \CHECK constraints. The \PK may be tested by following the above statement with further \INSERT statements that involve unique and non-unique values for the \sql{ID} column.


\inlineheading{Mutation Analysis of Relational Database Schemas}
Our previous work \cite{Kapfhammer2013,Wright2013,Wright2014} we developed a series of mutation operators for the integrity constraints of relational database schemas. 


