% vim: ft=tex
%!TEX root=../ast2016.tex

\vspace{-1ex}
\section{Virtual Mutation Analysis}
\label{sec:virtual-mutation-analysis}
\VMA of relational database schemas is the use of a model of DBMS to perform mutation analysis rather than communicating with a real instance of a DBMS.

In this paper, we derive a model for the \HyperSQL, \Postgres, and \SQLite DBMSs based on previous work \cite{McMinn2015} in which we modeled the behavior of the integrity constraints of different DBMSs. This model was originally motivated by the desire to derive different coverage criteria for testing the integrity constraints of a relational database schema. In this paper, we show how this same model can be used to evaluate mutants, and removes the need communicate with a real instance of a DBMS, and so potentially speeding up the time needed to perform mutation analysis.

\inlineheading{Modeling the Integrity Constraints of a DBMS}
McMinn et al. introduce {\it integrity constraint predicates} to model the integrity constraints that can be specified as part of a database schema for a DBMS. Integrity constraint predicates evaluate to {\it true} when a row of data in an \INSERT statement satisfies the constraint, and false when it does not.

As per the relational model, originally due to Codd~\cite{Codd1970}, a database table consists of a set of rows with identical columns names. We write an individual row as $r = (cl_1:v_1, \dots, cl_{ncl}:v_{ncl})$ for a table with $ncl$ columns, where $cl_{1 \ldots ncl}$ are the column names and $v_{1 \ldots ncl}$ are the values for each column. As a shorthand, we use the notation $\select{r}{cl}$ to refer to the value of a column $cl$ for a row $r$.

\begin{sloppypar}
\Figure{fig:integrity-constraint-functions} shows functions for obtaining integrity constraint predicates. The function
``get\_primary\_key\_constraint\_predicate'' gives a predicate for the standard DBMS implementation of a primary key,
while ``get\_primary\_key\_constraint\_predicate\_for\_SQLite'' is an especially customized version for \SQLite. \SQLite
differs from most other DBMSs in that \NULL values are legal entries for primary key columns. Both functions take the
configuration of a primary key represented as a set of columns $CL$ for a table $tbl$ and a row of data values $nr$. The
predicate returned by the function can then be used to decide, given the current state of the table $tbl$, whether the
values in $nr$ conform to the primary key of $tbl$ or not. For example, the predicate returned for the \PK of the
\sql{Station} table for a non-\SQLite DBMS such as \Postgres is:
\end{sloppypar}

\vspace{-.5em}
\begin{center}
\scalebox{\inlinescalefactor}{
$\selectneqnull{nr}{\sql{id}} \smallwedge \forallinrel{er}{\sql{Station}}: \selectneq{nr}{er}{\sql{id}})$
}
\end{center}
\vspace{-.5em}

\noindent That is, the value of \sql{id} in the row $nr$ must not
be \NULL, and it must not be identical to some other value for \sql{id} appearing in a row already present in the table.

\input{figures/integrity-constraint-predicates}

Once predicates have been obtained for all integrity constraints pertaining to a database table\footnote{{\scriptsize See McMinn \etal~\cite{McMinn2015} for a full list of functions for the integrity constraints for each of the database management systems that we study in this paper.}}, an {\it acceptance predicate} can be formed. An acceptance predicate describes whether a row of data (such as that which forms part of an \INSERT statement in a test case) conforms to all of the integrity constraints defined on a table, and as such, whether that row of data will be admitted into the database. An acceptance predicate is formed by the conjunction of each of the individual integrity constraint predicates.

% further examples ?

\inlineheading{Performing \VMA} Once an acceptance predicate is obtained for each of the tables of a database schema, they can be used to perform virtual mutation analysis. Instead of submitting the rows of data in the \INSERT statements of a test case directly to the DBMS, rows of data can instead be evaluated by the acceptance predicate relevant to the table that is the subject of the \INSERT. Whereas with standard mutation analysis, we seek to observe a difference in the acceptance and rejection behavior of the DBMS with respect to the \INSERT statements submitted as part of each test case, with \vma we instead seek to monitor difference in truth values of acceptance predicates when evaluated with the data contained within each of the original \INSERT statements of the test suite. Any difference in truth value of an acceptance predicate with the original schema and a mutant indicates that the mutant has been killed. As with standard mutation analysis, \vma can be used to compute a mutation score; that is, the number of mutants killed divided by all mutants under consideration.

One disadvantage of \vma is that a model of the operation of the integrity constraints is needed for the DBMS with which
we wish to test schemas and perform mutation analysis. While integrity constraints tend to operate in broadly the same
way across most DBMSs there is the potential for subtle variations due to differing interpretations of the SQL standard
(as shown with the primary key example with \SQLite). So, while we have a model --- that is accurate for \HyperSQL,
\Postgres and \SQLite and used in this paper --- new models may be required for \mbox{other DBMSs}.

%% TODO accentuate the following:
% savings
% no need set up the database
% no need to execute inserts against the database
% no need to clear down the database
