% vim: ft=tex
%!TEX root=ast2016.tex

\section{Virtual Mutation Analysis}
\label{sec:virtual-mutation-analysis}

Like mutation analysis for programs \cite{}, database schema mutation analysis is a time-consuming process. With database schema mutation analysis, the time cost incurred includes the overheads of communicating with a DBMS over a network socket. This can be a bottleneck even when the DBMS is running on the same machine as the process conducting the analysis and submitting the relevant SQL commands. 
% This might draw the question of why we didn't compare with mutant schemata
In previous work, we sought to minimize the amount of communication that needed to take place, for example by combining all mutants into a single database schema \cite{Wright2013}. This however, does not completely eliminate communication costs.

We propose an alternative approach of modeling the relevant behavior of the DBMS pertaining to the testing of integrity constraints, and using that model to perform mutation analysis ``virtually''---i.e., without the use of the actual DBMS in question. We derive this model from previous work \cite{McMinn2015} where we modeled the integrity constraints of different DBMSs in order to derive different coverage criteria to test them. In this paper, we argue that this model can be used to evaluate mutants. The use of model removes the need communicate with a real instance of a DBMS, thus potentially speeding up the time needed to evaluate mutants.

\inlineheading{Modeling the Integrity Constraints of a DBMS}
McMinn et al. introduce {\it integrity constraint predicates} to model integrity constraints that can be specified as part of a database schema for a DBMS. Integrity constraint predicates evaluate to {\it true} when a row of data in an \INSERT statement satisfies the constraint, and false when it does not.

As per the relational model, originally due to Codd~\cite{Codd1970}, a database table consists of a set of rows with identical columns names. We write an individual row as $r = (cl_1:v_1, \dots, cl_{ncl}:v_{ncl})$ for a table with $ncl$ columns, where $cl_{1 \ldots ncl}$ are the column names and $v_{1 \ldots ncl}$ are the values for each column. As a shorthand, we use the notation $\select{r}{cl}$ to refer to the value of a column $cl$ for a row $r$ and the use of $\relnull$ to denote \NULL.

\begin{sloppypar}
\Figure{fig:integrity-constraint-functions} shows functions for obtaining integrity constraint predicates. The function
``get\_primary\_key\_constraint\_predicate'' gives a predicate for the standard DBMS implementation of a primary key,
while ``get\_primary\_key\_constraint\_predicate\_for\_SQLite'' is an especially customized version for \SQLite. \SQLite
differs from most other DBMSs in that \NULL values are legal entries for primary key columns. Both functions take the
configuration of a primary key represented as a set of columns $CL$ for a table $tbl$ and a row of data values $nr$. The
predicate returned by the function can then be used to decide, given the current state of the table $tbl$, whether the
values in $nr$ conform to the primary key of $tbl$ or not. For example, the predicate returned for the \PK of the
\sql{Station} table for a non-\SQLite DBMS such as \Postgres is: \[\selectneqnull{nr}{\sql{id}} \smallwedge
\forallinrel{er}{\sql{Station}}: \selectneq{nr}{er}{\sql{id}})\] That is, the value of \sql{id} in the row $nr$ must not
be \NULL, and it must not be identical to some other value for \sql{id} in rows already in the table.
\end{sloppypar}

\input{figures/integrity-constraint-predicates}

Once predicates have been obtained for all integrity constraints pertaining to a database table (see McMinn \etal~\cite{McMinn2015} for a full list of functions for all integrity constraints and DBMSs studied in this paper), an {\it acceptance predicate} can be formed. An acceptance predicate describes when a row of data conforms to all integrity constraints, and as such, will be admitted into the database. It is formed by the conjunction of each of the individual integrity constraint predicates.

% further examples ?

\inlineheading{Performing \VMA}

Once an acceptance predicate is obtained for each of the tables of a database schema, they can be used to perform virtual mutation analysis. Instead of submitting the data in the \INSERT statements of a test case directly to the DBMS, they can instead be evaluated by the acceptance predicate relevant to the table that is the subject of the \INSERT. 

The disadvantage of \VMA is that a model of the operation of the integrity constraints for the DBMS concerned. While their operation is the same across most DBMSs there is the potential for subtle variations due to different interpretations of the SQL standard (as shown in the primary key example with \SQLite). Thus, while we have a model that is accurate for \HyperSQL, \Postgres and \SQLite, new models are potentially required for other DBMSs. 

