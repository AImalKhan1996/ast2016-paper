% vim: ft=tex
%!TEX root=../ast2016.tex

\vspace{-1ex}
\section{Virtual Mutation Analysis}
\label{sec:virtual-mutation-analysis}
\VMA of relational database schemas is the use of a model of DBMS to perform mutation analysis rather than communicating with a real instance of a DBMS. 

In this paper, we derive a model for the \HyperSQL, \Postgres, and \SQLite DBMSs based on previous work \cite{McMinn2015} in which we modeled the behavior of the integrity constraints of different DBMSs. This model was originally motivated by the desire to derive different coverage criteria for testing the integrity constraints of a relational database schema. In this paper, we show how this same model can be used to evaluate mutants, and removes the need communicate with a real instance of a DBMS, and so potentially speeding up the time needed to perform mutation analysis.

\inlineheading{Modeling the Integrity Constraints of a DBMS}
McMinn et al. introduce {\it integrity constraint predicates} to model integrity constraints that can be specified as part of a database schema for a DBMS. Integrity constraint predicates evaluate to {\it true} when a row of data in an \INSERT statement satisfies the constraint, and false when it does not.

As per the relational model, originally due to Codd~\cite{Codd1970}, a database table consists of a set of rows with identical columns names. We write an individual row as $r = (cl_1:v_1, \dots, cl_{ncl}:v_{ncl})$ for a table with $ncl$ columns, where $cl_{1 \ldots ncl}$ are the column names and $v_{1 \ldots ncl}$ are the values for each column. As a shorthand, we use the notation $\select{r}{cl}$ to refer to the value of a column $cl$ for a row $r$ and the use of $\relnull$ to denote \NULL.

\begin{sloppypar}
\Figure{fig:integrity-constraint-functions} shows functions for obtaining integrity constraint predicates. The function
``get\_primary\_key\_constraint\_predicate'' gives a predicate for the standard DBMS implementation of a primary key,
while ``get\_primary\_key\_constraint\_predicate\_for\_SQLite'' is an especially customized version for \SQLite. \SQLite
differs from most other DBMSs in that \NULL values are legal entries for primary key columns. Both functions take the
configuration of a primary key represented as a set of columns $CL$ for a table $tbl$ and a row of data values $nr$. The
predicate returned by the function can then be used to decide, given the current state of the table $tbl$, whether the
values in $nr$ conform to the primary key of $tbl$ or not. For example, the predicate returned for the \PK of the
\sql{Station} table for a non-\SQLite DBMS such as \Postgres is: \[\selectneqnull{nr}{\sql{id}} \smallwedge
\forallinrel{er}{\sql{Station}}: \selectneq{nr}{er}{\sql{id}})\] That is, the value of \sql{id} in the row $nr$ must not
be \NULL, and it must not be identical to some other value for \sql{id} in rows already in the table.
\end{sloppypar}

\input{figures/integrity-constraint-predicates}

Once predicates have been obtained for all integrity constraints pertaining to a database table (see McMinn \etal~\cite{McMinn2015} for a full list of functions for all integrity constraints and DBMSs studied in this paper), an {\it acceptance predicate} can be formed. An acceptance predicate describes when a row of data conforms to all integrity constraints, and as such, will be admitted into the database. It is formed by the conjunction of each of the individual integrity constraint predicates.

% further examples ?

\inlineheading{Performing \VMA}

Once an acceptance predicate is obtained for each of the tables of a database schema, they can be used to perform virtual mutation analysis. Instead of submitting the data in the \INSERT statements of a test case directly to the DBMS, they can instead be evaluated by the acceptance predicate relevant to the table that is the subject of the \INSERT. 

The disadvantage of \VMA is that a model of the operation of the integrity constraints for the DBMS concerned. While their operation is the same across most DBMSs there is the potential for subtle variations due to different interpretations of the SQL standard (as shown in the primary key example with \SQLite). Thus, while we have a model that is accurate for \HyperSQL, \Postgres and \SQLite, new models are potentially required for other DBMSs. 

